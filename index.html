<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rust: Mobile Warfare</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* HUD ELEMENTS */
        .hud-text { position: absolute; color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; pointer-events: none; }
        #health-hud { top: 20px; left: 20px; font-size: 24px; color: #e74c3c; }
        #ammo-hud { bottom: 100px; right: 20px; font-size: 32px; color: #f1c40f; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.8); }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        /* ACTION BUTTONS (Fixed) */
        .btn {
            position: absolute; pointer-events: auto;
            background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px); touch-action: manipulation;
        }
        .btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }

        #btn-fire { width: 70px; height: 70px; bottom: 40px; right: 30px; background: rgba(231, 76, 60, 0.4); border-color: #e74c3c; }
        #btn-jump { width: 60px; height: 60px; bottom: 150px; right: 120px; }
        #btn-reload { width: 50px; height: 50px; bottom: 40px; right: 120px; font-size: 12px; }

        /* DYNAMIC ZONES */
        #zone-left { position: absolute; top: 0; left: 0; width: 50%; height: 100%; pointer-events: auto; }
        #zone-right { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }

        /* JOYSTICK VISUAL */
        #joystick-base { position: absolute; width: 100px; height: 100px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); transform: translate(-50%, -50%); display: none; pointer-events: none; }
        #joystick-knob { position: absolute; width: 40px; height: 40px; background: rgba(255,255,255,0.5); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(0,0,0,0.5); }
    </style>
    
    <!-- High Performance 3D Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="game-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="health-hud">HP: 100/100</div>
        <div id="ammo-hud">30 / 90</div>
        <div id="crosshair"></div>

        <!-- Touch Zones -->
        <div id="zone-left"></div> <!-- Move -->
        <div id="zone-right"></div> <!-- Look -->

        <!-- Joystick Graphics -->
        <div id="joystick-base"><div id="joystick-knob"></div></div>

        <!-- Buttons -->
        <div id="btn-jump" class="btn">JUMP</div>
        <div id="btn-reload" class="btn">RELOAD</div>
        <div id="btn-fire" class="btn">FIRE</div>
    </div>

<script>
    /**
     * RUST: MOBILE WARFARE
     * High-End Single File Implementation
     */

    // --- CONFIG ---
    const SETTINGS = {
        sensitivity: 0.003, // Camera sensitivity
        playerSpeed: 10,
        jumpForce: 10,
        botCount: 5
    };

    // --- GLOBALS ---
    let scene, camera, renderer, world;
    let playerBody;
    const objects = [];
    const bots = [];
    let lastTime;
    
    // Input State
    const input = {
        move: { x: 0, y: 0, active: false, originX: 0, originY: 0 },
        look: { x: 0, y: 0, active: false, lastX: 0, lastY: 0 },
        shooting: false
    };

    // Player Euler Angles for Camera
    const pitch = new THREE.Object3D(); // Up/Down
    const yaw = new THREE.Object3D();   // Left/Right

    // --- TEXTURE GENERATOR (HD Realistic Look without External Assets) ---
    function createTexture(color, noise = 0.2) {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color;
        ctx.fillRect(0,0,size,size);
        
        // Add Noise
        for(let i=0; i<40000; i++) {
            ctx.fillStyle = `rgba(0,0,0,${Math.random() * noise})`;
            ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
            ctx.fillStyle = `rgba(255,255,255,${Math.random() * (noise/2)})`;
            ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }

    const texGround = createTexture('#3b6e3b', 0.3);
    const texWood = createTexture('#5d4037', 0.4);
    const texStone = createTexture('#7f8c8d', 0.2);

    // --- INIT GAME ---
    function init() {
        // 1. Setup Three.js
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 80);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 500;
        sun.shadow.camera.left = -100;
        sun.shadow.camera.right = 100;
        sun.shadow.camera.top = 100;
        sun.shadow.camera.bottom = -100;
        scene.add(sun);

        // 2. Setup Physics (Cannon.js)
        world = new CANNON.World();
        world.gravity.set(0, -9.82 * 2, 0); // Higher gravity for snappier feel
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Materials
        const physMat = new CANNON.Material('ground');
        const playerMat = new CANNON.Material('player');
        const contact = new CANNON.ContactMaterial(physMat, playerMat, { friction: 0.0, restitution: 0.0 });
        world.addContactMaterial(contact);

        // Ground
        const groundBody = new CANNON.Body({ mass: 0, material: physMat });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
        world.addBody(groundBody);

        // Visual Ground (Repeated Texture)
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        texGround.repeat.set(50, 50);
        const groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ map: texGround }));
        groundMesh.rotation.x = -Math.PI/2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // 3. Create Player
        createPlayer();

        // 4. Create World (Map)
        createMap();

        // 5. Create Bots
        for(let i=0; i<SETTINGS.botCount; i++) spawnBot();

        // 6. Controls Setup
        setupControls();

        // 7. Start Loop
        requestAnimationFrame(animate);
    }

    function createPlayer() {
        // Physics Body (Capsule simulation via Sphere)
        const shape = new CANNON.Sphere(0.8); 
        playerBody = new CANNON.Body({ mass: 70, material: new CANNON.Material() });
        playerBody.addShape(shape);
        playerBody.position.set(0, 5, 0);
        playerBody.linearDamping = 0.9; // Stops sliding
        playerBody.angularDamping = 1.0; // Prevent rolling
        playerBody.fixedRotation = true;
        world.addBody(playerBody);

        // Camera Rig
        // We attach camera to a dummy object to handle rotations separate from physics body
        yaw.position.copy(playerBody.position);
        yaw.add(pitch);
        pitch.add(camera);
        pitch.position.y = 0.6; // Eye height
        scene.add(yaw);
    }

    function createMap() {
        // Helper to create buildings
        function createBox(x, y, z, w, h, d, tex, mass=0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ map: tex });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y + h/2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass });
            body.addShape(shape);
            body.position.set(x, y + h/2, z);
            world.addBody(body);
        }

        // Random Buildings
        createBox(10, 0, -10, 4, 4, 4, texWood);
        createBox(-15, 0, -15, 6, 5, 6, texWood);
        createBox(20, 0, 20, 8, 3, 8, texStone);
        createBox(-20, 0, 20, 4, 6, 4, texWood);
        
        // Obstacles
        createBox(5, 0, 5, 2, 2, 2, texStone);
        createBox(-5, 0, 10, 3, 1, 3, texStone);

        // Walls (Arena)
        createBox(0, 0, -50, 100, 10, 2, texStone);
        createBox(0, 0, 50, 100, 10, 2, texStone);
        createBox(-50, 0, 0, 2, 10, 100, texStone);
        createBox(50, 0, 0, 2, 10, 100, texStone);
    }

    function spawnBot() {
        const geo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
        const mat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        scene.add(mesh);

        const shape = new CANNON.Sphere(0.6);
        const body = new CANNON.Body({ mass: 50 });
        body.addShape(shape);
        
        // Random Pos
        const x = (Math.random() - 0.5) * 80;
        const z = (Math.random() - 0.5) * 80;
        body.position.set(x, 5, z);
        body.linearDamping = 0.5;
        world.addBody(body);

        bots.push({ mesh, body, dir: Math.random() * Math.PI * 2, changeTimer: 0 });
    }

    // --- CONTROLS LOGIC (MOBILE FPS STYLE) ---
    function setupControls() {
        const leftZone = document.getElementById('zone-left');
        const rightZone = document.getElementById('zone-right');
        const joyBase = document.getElementById('joystick-base');
        const joyKnob = document.getElementById('joystick-knob');

        // 1. MOVEMENT (Dynamic Joystick)
        leftZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            input.move.active = true;
            input.move.originX = touch.clientX;
            input.move.originY = touch.clientY;
            
            // Show Visuals
            joyBase.style.display = 'block';
            joyBase.style.left = touch.clientX + 'px';
            joyBase.style.top = touch.clientY + 'px';
            joyKnob.style.transform = `translate(-50%, -50%)`;
        });

        leftZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if(!input.move.active) return;
            const touch = e.changedTouches[0];
            
            const maxDist = 50;
            let dx = touch.clientX - input.move.originX;
            let dy = touch.clientY - input.move.originY;
            
            const dist = Math.min(maxDist, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            
            const moveX = Math.cos(angle) * dist;
            const moveY = Math.sin(angle) * dist;

            joyKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
            
            // Normalize Input -1 to 1
            input.move.x = moveX / maxDist;
            input.move.y = moveY / maxDist;
        });

        const endMove = () => {
            input.move.active = false;
            input.move.x = 0;
            input.move.y = 0;
            joyBase.style.display = 'none';
        };
        leftZone.addEventListener('touchend', endMove);
        leftZone.addEventListener('touchcancel', endMove);

        // 2. LOOKING (Camera Swipe)
        rightZone.addEventListener('touchstart', (e) => {
            input.look.active = true;
            input.look.lastX = e.changedTouches[0].clientX;
            input.look.lastY = e.changedTouches[0].clientY;
        });

        rightZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if(!input.look.active) return;
            const touch = e.changedTouches[0];
            
            const dx = touch.clientX - input.look.lastX;
            const dy = touch.clientY - input.look.lastY;
            
            input.look.lastX = touch.clientX;
            input.look.lastY = touch.clientY;

            // Rotate Camera (Inverted Y axis is standard for PC, but mobile often prefers non-inverted)
            // Let's do Standard FPS: Left swipe = Turn Left
            yaw.rotation.y -= dx * SETTINGS.sensitivity;
            pitch.rotation.x -= dy * SETTINGS.sensitivity;
            
            // Clamp Pitch (Look up/down limit)
            pitch.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch.rotation.x));
        });

        const endLook = () => { input.look.active = false; };
        rightZone.addEventListener('touchend', endLook);
        rightZone.addEventListener('touchcancel', endLook);

        // 3. BUTTONS
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Only jump if touching ground (raycast or velocity check)
            if(Math.abs(playerBody.velocity.y) < 0.1) {
                playerBody.velocity.y = SETTINGS.jumpForce;
            }
        });

        document.getElementById('btn-fire').addEventListener('touchstart', (e) => {
            e.preventDefault();
            shoot();
        });
    }

    function shoot() {
        // Visual Flash
        const flash = document.createElement('div');
        flash.style.position = 'absolute';
        flash.style.top = '0'; flash.style.left = '0';
        flash.style.width = '100%'; flash.style.height = '100%';
        flash.style.background = 'rgba(255,255,0,0.1)';
        flash.style.pointerEvents = 'none';
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 50);

        // Raycast
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        
        // Check Hits on Bots
        const botMeshes = bots.map(b => b.mesh);
        const intersects = raycaster.intersectObjects(botMeshes);

        if(intersects.length > 0) {
            const hitObj = intersects[0].object;
            // Find bot
            const botIndex = bots.findIndex(b => b.mesh === hitObj);
            if(botIndex > -1) {
                // Kill Bot (Respawn)
                const b = bots[botIndex];
                scene.remove(b.mesh);
                world.removeBody(b.body);
                bots.splice(botIndex, 1);
                
                // Spawn new one later
                setTimeout(spawnBot, 3000);
                
                // Update UI
                document.getElementById('health-hud').innerText = "KILL +100";
                setTimeout(() => document.getElementById('health-hud').innerText = "HP: 100/100", 1000);
            }
        }
    }

    // --- MAIN LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        
        const dt = 1/60;

        // 1. Physics Step
        world.step(dt);

        // 2. Player Movement Logic
        // Get Forward/Right vectors based on Yaw (Horizontal rotation only)
        const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw.rotation.y);
        const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw.rotation.y);

        const moveVec = new THREE.Vector3()
            .addScaledVector(forward, input.move.y) // Forward is -Z in logic, but Joystick Up is -Y. Logic matches if mapped right.
            .addScaledVector(right, input.move.x);

        // Apply velocity
        playerBody.velocity.x = moveVec.x * SETTINGS.playerSpeed;
        playerBody.velocity.z = moveVec.z * SETTINGS.playerSpeed;

        // Sync Camera to Physics Body
        yaw.position.copy(playerBody.position);

        // 3. Update Bots (Simple AI)
        bots.forEach(bot => {
            bot.body.velocity.x = Math.cos(bot.dir) * 2;
            bot.body.velocity.z = Math.sin(bot.dir) * 2;
            
            // Face direction
            bot.mesh.position.copy(bot.body.position);
            bot.mesh.rotation.y = -bot.dir;

            // Change direction randomly
            bot.changeTimer++;
            if(bot.changeTimer > 60) {
                bot.dir += (Math.random() - 0.5);
                bot.changeTimer = 0;
            }
        });

        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();

</script>
</body>
</html>
